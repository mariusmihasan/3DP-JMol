
// This is the initial loading and preparation of the molecule.
// Loading will be handled by the website (method to be determined). A decision is needed regarding hydrogen atoms.
//load *8jiv //ribosome from EBI - extremely large
//load =1rbp //large ?? protein, b sheets example
load =2HHB //medium protein
//load =4ins //small protein
//load =4rna //tRNA, printing in balls and sticks was difficult
//load =2bna //DNA, printing in balls and sticks was easy 
//load :nicotine //small molecule, printing in balls and sticks at 100% is recommended

// Issue observed - some pdb are loaded in more copies, other not complete. Have something to do with the biounit? How this can be solved?
// This part is an initial set-up of the molecule. 

// For this part of the script the original author is Dr. Angel Herráez, Biochemistry and Molecular Biology, Dept. of Systems Biology, University of Alcalá, E-28805 Alcalá de Henares  (Madrid), Spain (https://biomodel.uah.es/)

set echo wk 50% 100%;
set echo wk center;
font echo 22;
color echo yellow;
background echo [xA040A0];
echo "         working...         ";
refresh;

spin off; anim off;
delete solvent,ions,[NA],[K],[CL],[BR],[GOL],[DIO],[DOX],[NO],[NO3],[EDO],[DMS],[FMT],[ACT],[IPA]; //MM will keep hydrogens for now, needs a decision - maybe depending on style
delete not (model=1.1);
configuration 1; delete not selected; select all; // MM - dont know thei purpose for now, related to selection
center visible;
set cartoonFancy on; // MM - dont know thei purpose for now
set hermiteLevel 4; //MM - Increasing it to 6 does not show improvemnt in the stl surfaces. Determines the amount of curve smoothing used in rendering protein and nucleic acid secondary structures involving cartoon, ribbbon, rocket, and trace. A value of 4 or -4 might be a reasonable compromise between look and performance. 
set ribbonAspectRatio 2; // MM - Sets the thickness of the ribbons in ribbon and cartoon renderings in terms of the width:height aspect ratio; Default looks like 30/7.5 = 4. Should not be required, the scalling ensures that thikness is always ok.
set hbondsSolid true;

/* COLORS:  ==============================================
*/
cHb = 'deepskyblue'; // H bonds [xFDF5E6]
cSurf = 'yellowTint'; // isosurfaces

select protein;
color backbone dodgerBlue;
color trace dodgerBlue;
color ribbons dodgerBlue;
color cartoon dodgerBlue;

select nucleic;
color backbone mediumOrchid;
color trace mediumOrchid;
color ribbons mediumOrchid;
color cartoon mediumOrchid;

select all;
color ssBonds yellow;

function checkStruts() {  // for debugging ligand struts
  display not ~poly;
  display add connected(displayed);
  print "Reset with 'display all' ";
}

// MM - resets the wireframe style 
function rSet() {
  // acts on current selection
  wireframe only;
  wireframe off;
}

define ~prot protein and polymerLength>4; // MM - dont know thei purpose for now
define ~dna dna and polymerLength>4; // MM - dont know thei purpose for now
define ~rna rna and polymerLength>4; // MM - dont know thei purpose for now
define ~nuc ~dna or ~rna; // MM - dont know thei purpose for now
define ~poly ~prot or ~nuc; // MM - dont know thei purpose for now
define ~node alpha or (*.P and nucleic); //nodes for backbone/trace // MM - dont know thei purpose for now
define ~nodeN ~node and nucleic; // MM - dont know thei purpose for now

// End of the part from Dr. Angel Herráez, Biochemistry and Molecular Biology, Dept. of Systems Biology, University of Alcalá, E-28805 Alcalá de Henares  (Madrid), Spain (https://biomodel.uah.es/)

SET pdbAddHydrogens // this needs to be decided

print "- Reading information related to the molecule: size, smallest and largest atom, smallest bond length";
// First step is to get some info related to the target molecule: size, smallest and largest atom, smallest bond length;
// Estimating size - this dictates the final maximum printing scale in the slicer (Prusa, Cura, Orca, etc). This is done by calculating the bounding box X, Y, and Z dimensions and identifying the largest dimension (var maxDim in this script).
// Enable the bounding box
boundbox on;
refresh;

// Retrieve bounding box properties
var centerStr = getProperty("boundBoxInfo", "center");
var corner0Str = getProperty("boundBoxInfo", "corner0");
var corner1Str = getProperty("boundBoxInfo", "corner1");
var vectorStr = getProperty("boundBoxInfo", "vector");

// Convert extracted properties into numerical arrays
var center = [ centerStr.x, centerStr.y, centerStr.z ];
var corner0 = [ corner0Str.x, corner0Str.y, corner0Str.z ];
var corner1 = [ corner1Str.x, corner1Str.y, corner1Str.z ];
var vector = [ vectorStr.x, vectorStr.y, vectorStr.z ];

// Ensure the values are retrieved before proceeding
if (center == null || corner0 == null || corner1 == null || vector == null) {
  print "ERROR: Bounding box data not retrieved.";
  exit;
}

// Calculate dimensions using vector
var length = 2 * vector[0];  // X-axis (width)
var height = 2 * vector[1];  // Y-axis (height)
var depth = 2 * vector[2];   // Z-axis (depth)

// // Alternative method (verification check)
var length_check = corner1[0] - corner0[0];
var height_check = corner1[1] - corner0[1];
var depth_check = corner1[2] - corner0[2];

// Ensure consistency
if (abs(length - length_check) > 0.1 || abs(height - height_check) > 0.1 || abs(depth - depth_check) > 0.1) {
    length = length_check;
    height = height_check;
    depth = depth_check;
}

// Calculate volume
var volume = length * height * depth;

// Determine the largest dimension
var maxDim = length;
var maxLabel = "Length";

if (height > maxDim) {
    maxDim = height;
    maxLabel = "Height";
}
if (depth > maxDim) {
    maxDim = depth;
    maxLabel = "Depth";
}
boundbox off;

// The largest dimension as maxDim calculation is complete. 
// Determine the the length of the shortest bond and the spacefill value of the smalest and largest atoms. Useful for estimating  rendering corections. 
// Retrieve bond length information and calculate MinBondLength 
var bondLengths = getProperty("bondInfo", "length_Ang")
// Initialize MinBondLength with a large value
var MinBondLength = 10 
// Determine the minimum bond length (1-based index)
for (var i = 1; i <= bondLengths.length; i = i + 1) {
    if (bondLengths[i] < MinBondLength) {
        MinBondLength = bondLengths[i]
    }
}
// Retrieve the atom spacefill values from the atomInfo
var atomData = getProperty("atomInfo");

// Initialize the smallest and largest spacefill values with extreme initial values
var minSpacefill = 10;  // Arbitrary large initial value
var maxSpacefill = 0;   // Arbitrary small initial value

// Loop through the atoms and find the minimum and maximum spacefill values
for (var i = 1; i < atomData.length; i++) {
    var spacefillValue = atomData[i].spacefill;
    if (spacefillValue < minSpacefill) {
        minSpacefill = spacefillValue;
    }
    if (spacefillValue > maxSpacefill) {
        maxSpacefill = spacefillValue;
    }
}

print "-- Setting up 3D printing environment ";
// Here we set-up and list all technical variables related to the 3d-printers, dimensions, thresholds etc. These are important for calculations and are defined here for easy modification.
 
var JMolStlScale = 10.0; // Jmol exports 1 A as 10 mm in stl files. This means that all dimesnions in Jmol are exported 10x larger. We will do all math in A, and for the final result in mm with will multiply this. We will keep it here for reference and in case JMol changes this in the future.// Stl files are only in one color. OBJ export keeps colors and should be supported by all slicers. When exported as obj, JMolStlScale = 1.0 but math in the script should be checked especially for atom sizes.

var MinPrintedObjDimen = 3.0 / JMolStlScale; //minimum printed dimension of an object (bond, or thikness). In the paper is 2.6. We will use 3 mm for more sturdy models. Divided by the JMolStlScale as we work in A. Some limits (atoms vWr % in this script, maybe other, will depend on this)

var RefBondLength = 2.86; //dimension of a C-C and peptide length in A used to calculate minimum printing scale. Based on Math, needs validation by printing

var AtomToBondDiamRatio = 0.78 / MinPrintedObjDimen //ratio between an C atom diameter and a covalent bond thicknes
// Calculate the AtomToBondLengthRatio value based on the diameter of the smallest atom and the length of the shortest length;
var AtomToBondLengthRatio = (2 * MaxSpacefill) / MinBondLength;

// Define scaling factor for atom space fill as I do not know radii. 0.23 is default scalling for a C atom in Jmol, 0.2 is default scalling for a H atom in Jmol
var AtomScalingFactor = 0.20; // Adjust this if needed based on printing results

var PrintBedMinDimension = 210.0 / JMolStlScale; // Introduce the PrintBedMinDimension variable. This is the minimum dimension (X, Y, or Z) of the print bed in mm and divided by the JMolStlScale as we work in A. For now, it is set manually in the script here, but it might be advisable/required to have a way of setting it from the browser. 

// End of the section related to technical variables of the 3d-printers and dimensions, etc.

// Next is to calculate the scale factor for the maximum print. Maximum print scale (MaxPrintScale) depends on the minimum print bed dimension (X, Y, or Z) and maxDim. The final print scale is decided/sugested later
// Calculate MaxPrintScaleFactor - used for scaling dimensions later.
var MaxPrintScaleFactor = PrintBedMinDimension / maxDim;

// Setting up the print scale (PrintScaleFactor). Making sure that is always no less the 1 will ensure that small molecules will alway be printed at max. 100% if are small enough - will not scale the small molecules from PubChem to ridiculous sizes. Can switch between user selectable and MaxPrintScaleFactor ;

var PrintScaleFactorUser = 0.3;  // User input for PrintScaleFactor (can be 0 or any non-zero value)

var PrintScaleFactor = MaxPrintScaleFactor;  // Initialize PrintScaleFactor with MaxPrintScaleFactor

if (PrintScaleFactorUser == 0) {  // 
    // When PrintScaleFactorUser is 0, apply the logic based on MaxPrintScaleFactor
    if (MaxPrintScaleFactor < 1) {
        PrintScaleFactor = MaxPrintScaleFactor;  // If MaxPrintScaleFactor is less than 1, use it
    } else {
        PrintScaleFactor = 1;  // Otherwise, set PrintScaleFactor to 1
    }
} else {
    // When PrintScaleFactorUser is non-zero, set PrintScaleFactor to PrintScaleFactorUser
    PrintScaleFactor = PrintScaleFactorUser;
}

// calculation of the print factors is now complete

// Compute rendering factors as limits for each visualization style
//For Atoms and Sticks
// Compute and apply bonds dimensions;
var bonds_radius = (MinPrintedObjDimen/PrintScaleFactor) / 2;

// Compute scaling factor for atoms as %;
var MinAtomReqSize = MinPrintedObjDimen * PrintScaleFactor
var ActualAtomReqSize = minSpacefill
var AtomsScaledPercent = point(((minSpacefill * AtomScalingFactor) / (MinPrintedObjDimen * PrintScaleFactor) * 100)+ 0.5);

// Set-up limits for the max AtomsScaledPercent depending on the MinBondLength (largest two atoms will never overlap over the shortest bond)
var AtomsScaledPercentMax = point((maxSpacefill/MinBondLength) *100 + 0.5);

// First limits for the max AtomsScaledPercent depending on the bonds_radius (smalest atoms will not be covered by thick bonds)
var AtomsScaledPercentMax2 = point((minSpacefill/(bonds_radius * 2)) * 100 + 5 + 0.5); 
// Ensure AtomsScaledPercent does not exceed any of the maxAtomsScale.

var AtomsScaledPercent_corrected = AtomsScaledPercent;

// Determine the higher value between AtomsScaledPercentMax2 and AtomsScaledPercentMax
var AtomsScaledPercent_corrected = AtomsScaledPercent;

// If AtomsScaledPercent_corrected is greater than AtomsScaledPercentMax2 OR AtomsScaledPercentMax, set it to the larger of the two
if (AtomsScaledPercent_corrected > AtomsScaledPercentMax2 || AtomsScaledPercent_corrected > AtomsScaledPercentMax) {
    if (AtomsScaledPercentMax2 > AtomsScaledPercentMax) {
        AtomsScaledPercent_corrected = AtomsScaledPercentMax2;
    } else {
        AtomsScaledPercent_corrected = AtomsScaledPercentMax;
    }
}

// end of rendering setup for balls and sticks

// Calculating theresholds for each visualisation style, deciding print scales and outputing real-world dimensions of the final print;

//Thresholds for rendering scale in Jmol for each rendering scheme. This sets up how min the objects are rendred in JMol related to the final printing scale. 


var MinThresholdScaleFactorBallStick = (bonds_radius * 2)/((minSpacefill * AtomScalingFactor) * AtomsScaledPercent); // Ball and Stick Model // scale at which the diameter of the smallest atom is equal with the bond with (MinPrintedObjDimen). Usually the smallest atom is H. Could go lower as for example for a bigger atom C 

var MinThresholdScaleFactorBackbone = (MinPrintedObjDimen * 1.5)/(1.4 * 2); // Backbone models //Default backbone radius in JMol in 0.3 A. If backbone go up, it will be so thick that the helix pitch (4,75 A) and the helix inside (theoretical radius 2.3) will not be visible anymore. I will test with inside of the helix, and put a limit to have at least 1.8 A empty space - maximum radius for the backbone will be 2.3 - (1.8/2) = 1.4 A. Backbone is bbR(1.5 * bond radius). Hence bond radius max is 1.4/1.5. But bond radius is (MinPrintedObjDimen/PrintScaleFactor) / 2, so we calculate PrintScaleFactor as the formula in var.

var MinThresholdScaleFactorTrace = MinPrintedObjDimen / 1.3 ; //Trace model //Same as logic as for backbone, but  empty space needs to go higher to have more space inside the helix for easier support removal - 2 A. Trace radius max (tR = (bR * 2) is hence 2.3 - (2/2) = 1.3. Bond radius is then 1.4 / 2. But bond radius is (MinPrintedObjDimen/PrintScaleFactor) / 2, so we calculate PrintScaleFactor as the formula in var.

var MinThresholdScaleFactorRibbon = MinPrintedObjDimen/(0.85 * 2); // If  ribbon goes up, it will be so thick that the helix pitch and the helix inside will not be visible anymore. Theretical helix diameter is 4.5, helix pitch is 5.4. We will keep at least 1.5 A empty space. This means that the ribbon width (bond radius * 2) can not be higher then (5.4-1.5)/2 = 1.95 for width contraint, hence bond radius max is 0.85, and the ribbon thicknes (bond radius) can not be higher then (4,5-1.5)/2=1,5 for thicknes constraint. Bond radius is (MinPrintedObjDimen/PrintScaleFactor) / 2, and we calculate PrintScaleFactor which is the limit. 

var MinThresholdScaleFactorCartoon = MinPrintedObjDimen/2; // Same as logic as for backbone, but does not work - coils are rendered ok by (tR = (bR * 2)), helices and sheets are not. Dont know how to connect the helices and sheets with the coils dimensions (tR = (bR * 2). This needs work, arrows dimensions are not tacken into account

// Spacefill — will continue here
var MinThresholdScaleFactorSurface = 0.025; //temporary, from the paper, needs math. I will be used for both CPK (spacefill) and both surfaces (ses and sas) 

// Calculate MinPrintScaleFactor - planned to be used for calculating dimensions later. Lowest value among the set. Needs testing.
var MinPrintScaleFactor = MinThresholdScaleFactorSurface;

print "----------------------------------------------";
print "--- Start for 3D Printing RECOMMENDATIONS ----";

//Calculate min and max printing scale in % to be displayed
var MaxPrintScale = MaxPrintScaleFactor*100;
var MinPrintScale = MinPrintScaleFactor*100;
var PrintScale = PrintScaleFactor*100;

// rounding up scale values for display
var MaxPrintScale_round = point(MaxPrintScale + 0.5);    // rounding up
var MinPrintScale_round = point(MinPrintScale + 0.5);    // rounding up
var PrintScale_round = point(PrintScale + 0.5);    // rounding up

// text here needs to be edited depending on the final decision on how the var PrintBedMinDimension and PrintScaleFactor will be implemented (fixed or user selectable)

print "Rendering and printing recommendations are provided for a medium size (ie. Ender 3; Prusa MK3S+) FDM 3D printer. Using SLA printers is possible, but not yet tested.";

// Print recommendations based on the PrintScale value. Thresholds are listed above in the technical specifications section. The 0.3 value is arbitrary and requires adjustment.

if (MaxPrintScaleFactor > 1) {
    print "Your molecule is small. All renderings are suitable and can be printed. We recommend printing it at a scale of 100%.";
} else if (MaxPrintScaleFactor > MinThresholdScaleFactorBallStick) {
    print "Your molecule is rather small. All styles are suitable and can be printed.";
} else if (MaxPrintScaleFactor > MinThresholdScaleFactorTrace) {
    print "Your molecule is medium sized. All styles except Ball and Stick can be printed.";
} else if (MaxPrintScaleFactor > MinThresholdScaleFactorRibbon) {
    print "Your molecule is medium sized. All styles except Ball and Stick and Trace can be printed.";
} else if (MaxPrintScaleFactor > MinThresholdScaleFactorBackbone) {
    print "Your molecule is rather large. Only Backbone and Surface style can be printed.";
} else if (MaxPrintScaleFactor >= MinThresholdScaleFactorSurface) {
    print "Your molecule is large. Only Surface style can be printed.";
} else {
    print "Your molecule is huge. Sorry, but we can not generate printable models for it.";
}

// Output approximate real-world print dimensions in mm at MaxPrintScale 
// Compute raw values first
var max_length_raw = length * MaxPrintScaleFactor * JMolStlScale;
var max_height_raw = height * MaxPrintScaleFactor * JMolStlScale;
var max_depth_raw = depth * MaxPrintScaleFactor * JMolStlScale;
// Round values to the nearest integer
var max_length_mm = point(max_length_raw + 0.5);  // rounding up
var max_height_mm = point(max_height_raw + 0.5);  // rounding up
var max_depth_mm = point(max_depth_raw + 0.5);    // rounding up
print "Printed at a maximum allowed printing scale of " + MaxPrintScale_round + " % , your model will be approx " + max_length_mm + " mm x " + max_height_mm + " mm x " + max_depth_mm + " mm.";

// Output approximate real-world print dimensions in mm at MinPrintScale 
// Compute raw values first
var min_length_raw = length * MinPrintScaleFactor * JMolStlScale;
var min_height_raw = height * MinPrintScaleFactor * JMolStlScale;
var min_depth_raw = depth * MinPrintScaleFactor * JMolStlScale;
// Round values to the nearest integer
var min_length_mm = point(min_length_raw + 0.5);  // rounding up
var min_height_mm = point(min_height_raw + 0.5);  // rounding up
var min_depth_mm = point(min_depth_raw + 0.5);    // rounding up
print "Printed at a minimum printing scale of " + MinPrintScale_round + " % , your model will be approx " + min_length_mm + " mm x " + min_height_mm + " mm x " + min_depth_mm + " mm. Printing at smaller scales might still pe possible, but atomic details (H atoms) will be lost.";

// Output approximate real-world print dimensions in mm at curent scale/user 
// Compute raw values first
var user_length_raw = length * PrintScaleFactor * JMolStlScale;
var user_height_raw = height * PrintScaleFactor * JMolStlScale;
var user_depth_raw = depth * PrintScaleFactor * JMolStlScale;
// Round values to the nearest integer
var user_length_mm = point(user_length_raw + 0.5);  // rounding up
var user_height_mm = point(user_height_raw + 0.5);  // rounding up
var user_depth_mm = point(user_depth_raw + 0.5);    // rounding up
print "Printed at the curent scale/user selected scale of " + PrintScale_round + " % , your model will be approx " + user_length_mm + " mm x " + user_height_mm + " mm x " + user_depth_mm + " mm.";

print "--- End for 3D Printing RECOMMENDATIONS ----";
print "--------------------------------------------";

// For this part of the script the original author is Dr. Angel Herráez, Biochemistry and Molecular Biology, Dept. of Systems Biology, University of Alcalá, E-28805 Alcalá de Henares  (Madrid), Spain (https://biomodel.uah.es/). Ugly adapted to work with the dimensions calculated above.
/* IMPLEMENTING DIMENSIONS:  ==============================================
*/
bR = bonds_radius; /* bonds including for ligands) */
aR = AtomsScaledPercent_corrected; /* atoms  including for ligands) */
sR = (bonds_radius * 0.8); /* struts slighter thiner */ 
ssR = (bonds_radius * 0.9); /* SSbonds slighter thiner */
hR = (bonds_radius * 0.8); /* Hbonds  slighter thiner */
bbR = (bR * 1.5); /* backbone thicker the a bond */
tR = (bR * 2); /* trace, ribbons, blocks (nucleic cartoons) are thicker the a bond */ // this is the width of the element. Thicknes is half, meaning bR

// End of the part from Dr. Angel Herráez and adapted by me


/* RENDERING:  ==============================================
*/

var opt = "trace" // to be connected with the website // Possible implemented values so far: ballandstick; backbone; trace; cartoon; ribbon; blocks; spacefill, surface
//Possible styles in Jmol for structure: Backbone, Cartoon, Cartoon Rockets, Ribbons, Rockets, Strands (not printable), Trace.
//Possible styles in Jmol for Scheme: CPK Spacefill, Ball and Stick, Stiks, Wireframe, Cartoon, Trace. 

if (opt == "ballandstick");
    calculate hbonds // this needs to be decided
    color hbonds @cHb;
    calculate struts // this needs to be decided, related to Angels script. 
    wireframe @bR; 
    hbonds @hR;
    struts @sR;
    ssBonds @ssR;
    spacefill @{aR}%;
endif;

// For this part of the script the original author is Dr. Angel Herráez, Biochemistry and Molecular Biology, Dept. of Systems Biology, University of Alcalá, E-28805 Alcalá de Henares  (Madrid), Spain (https://biomodel.uah.es/).

if (opt=='backbone');
    // Protein backbone
    select ~prot;
    rSet();
    hbonds off;
    isosurface delete;
    backbone @{-bbR};
    set ssbonds backbone;
    ssBonds @ssR;
    select all;
endif;

if (opt=='trace');
// Protein trace
    select ~prot;
    rSet();
    hbonds off;
    isosurface delete;
    trace @{-tR};
    set ssbonds backbone;
    ssBonds @ssR;
    select all;
endif;

//cartoon needs work. Arrows tip is much to thin to ensure succesfull print and dont know how to change it. Also, secundary structures are rendered thinner than the coil. 
if (opt=='cartoon');
// Protein ribbon
  select ~prot;
  rSet();
  hbonds off;
  isosurface delete;
  cartoon @{-tR};
  set ssbonds backbone;
  ssBonds @ssR;
  select all;
endif;

if (opt=='ribbon');
// Protein ribbon
  select ~prot;
  rSet();
  hbonds off;
  isosurface delete;
  ribbons @{-tR};
  set ssbonds backbone;
  ssBonds @ssR;
  select all;
endif;

if (opt=='backbone');
// DNA backbone
  select ~nuc;
  rSet();
  isosurface delete;
  backbone @{-bbR};
  calculate hbonds;
  hbonds @hR;
  color hbonds @cHb;
  select ~dna;
  wireframe @{bR*1.2};
  select ~rna;
  wireframe @{bR*1.0};
  select all;
endif;

if (opt=='trace');
// DNA trace
  select ~nuc;
  rSet();
  isosurface delete;
  trace @{-tR};
  calculate hbonds;
  hbonds @hR;
  color hbonds @cHb;
  select ~dna;
  wireframe @{bR*1.2};
  select ~rna;
  wireframe @{bR*1.0};
  select all;
  endif;

if (opt=='ribbon');
  // DNA ribbon
  select ~nuc;
  rSet();
  isosurface delete;
  ribbons @{-tR};
  calculate hbonds;
  hbonds @hR;
  color hbonds @cHb;
  select ~dna;
  wireframe @{bR*1.2};
  select ~rna;
  wireframe @{bR*1.0};
  select all;
endif;

if (opt=='blocks');// dont think we need this one
// DNA/RNA blocks
  select ~nuc;
  rSet();
  isosurface delete;
  calculate hbonds;
  hbonds @hR;
  color hbonds @cHb;
  set cartoonBlocks on;
  set cartoonBlockHeight @{tR*0.8};
  cartoon @{-tR};
  select all;
endif;

if (opt=='spacefill'); // dont think we need this one
// whole model
  select all;
  rSet();
  isosurface delete;
  spacefill 100%// from AH @{-aR}; // this needs some thought, might not work as expected
  set ssbonds sidechain;
  ssBonds @ssR;
endif;

// Ligands
  select (not ~poly);
  rSet();
  wireframe @bR;
  spacefill @{aR}%;;

// Struts
  select all;
  connect struts delete;
  select protein;
  calculate struts;
select all;

// Ligand<->Protein/Nucleic struts
function ligandProteinStruts() {
  var ~L = {(not ~poly)};
  if (~L.length==0) { return; /* no ligands */ }

  var ~LG = getProperty('ligandInfo.ligands');

  /*
  // add other HET ligands not listed:  produces too many weird struts
  HN = getProperty('fileInfo.hetnam').lines;
  for (var i=1; i<=HN.size; i++) {
    var m = HN[i];
    m = m[12][14].trim(); //column positions of group name
    var found = false;
    for (var j=1; j<=~LG.size; j++) {
      if (~LG[j].groupNames == m) { found = true; }
    }
    x = {m}
    if (!found) {~LG.push({ "groupNames":m, "atoms":{@m} }) }
  }
  */

  for (i=1; i<=~LG.size; i++) {
    if (~LG[i].atoms.size == 1) {
        /* for ONE-ATOM LIGANDS (ions):
           links ion to the closest alphaCarbon or P (strut to trace or backbone)
        */
      var ~ligA = ~LG[i].atoms;
      var ~protA = {~poly} and connected({~ligA}) and within(chain, {~ligA});
      var D = [];
      for (var j in @~protA) {
        D.push( [j.distance( {~ligA} ), {(within(group, {j}) and ~node)}.atomIndex ] );
      }
      D.sort(1);
      define ~pA (atomIndex=@{D[1].[2]});
      connect ( {~ligA} ) ( within(group, ~pA) and ~node ) strut;
      print "->> Struts for one-atom ligand #" + i + ", " + ~LG[i].groupNames;
    } else { //>1
        /* for LINKED LIGANDS:
            links ~ligA to the alphaCarbon or P of that residue (strut to trace or backbone)
        */
      var ~lig = ~LG[i].atoms;
      var ~protA = {~poly} and connected({~lig}); // linked atoms in protein
      if ( ~protA.size>0 ) {
        var ~ligA = {~lig} and connected({~protA}); // linked atom in ligand
        connect ( {~ligA} ) ( within(group, {~protA}) and ~node ) strut;
        print "->> Struts for linked atom in ligand #" + i + ", " + ~LG[i].groupNames;
      } else { // NON-LINKED LIGAND
        var ~lig = ~LG[i].atoms;
        var nLigandStruts = 3;
        var D = []; // distances between ligand atoms and protein alpha or nucleic P atoms
        var P = {(~node and within(6.0,~lig))};
        for (var j=1; j<={~lig}.size; j++) {
          for (var k=1; k<=P.size; k++) {
            D.push( [{~lig}[j].distance(P[k]), {~lig}[j].atomIndex, P[k].atomIndex] );
          }
        }
        D.sort(1); // lowest distances first
        
        /* to pick "nLigandStruts" closest ligand-protein atom pairs, avoiding 2 struts on the same atom
        */
        var strutL = []; 
        var strutP = [];
        for (var j=1; j<D.size; j++) {
          var ~ligA = D[j].[2]; //atomIndex numbers
          var ~protA = D[j].[3];
          if ( !strutL.find(~ligA) && !strutP.find(~protA) ) { 
            strutL.push(~ligA); strutP.push(~protA);
          }
          if (strutL.length==nLigandStruts) { break; }
        }
        for (var j=1; j<=nLigandStruts; j++) { /* add struts from ligand to protein */
          connect ({atomIndex=@{strutL[j]}}) ({atomIndex=@{strutP[j]}}) strut;
        }
        print "->> Struts for non-linked ligand #" + i + ", " + ~LG[i].groupNames;
      } //end not linked
    } //end >1
  } //end for i
  select all;
} //end function

// struts between Protein and Nucleic:
function NucleicProteinStruts() {
  var nNucProtStruts = 6;
  var D = []; // distances between nucleic and protein node atoms (Calpha and P)
  define ~nodeN ~node and nucleic;
  var P = {(~node and protein and within(6.0,~nodeN))};
  for (var j=1; j<={~nodeN}.size; j++) {
  	for (var k=1; k<=P.size; k++) {
  		D.push( [{~nodeN}[j].distance(P[k]), {~nodeN}[j].atomIndex, P[k].atomIndex] );
  	}
  }
  D.sort(1); // lowest distances first
  
  var strutN = []; 
  var strutP = [];
  for (var j=1; j<D.size; j++) {
  	var ~nucA = D[j].[2]; //atomIndex numbers
  	var ~protA = D[j].[3];
  	if ( !strutN.find(~nucA) && !strutP.find(~protA) ) { 
  		strutN.push(~nucA); strutP.push(~protA);
  	}
  	if (strutN.length==nNucProtStruts) { break; }
  }
  for (var j=1; j<=nNucProtStruts; j++) { /* add struts from nucleic to protein */ 
  	connect ({atomIndex=@{strutN[j]}}) ({atomIndex=@{strutP[j]}}) strut;
  }
} //end function

if (LigStruts) { ligandProteinStruts(); }
if (NucProtStruts==1) { NucleicProteinStruts(); }

struts @sR; 
color struts translucent 0.4 navajoWhite;
/* affects both default (protein) struts and those created with "connect" */


// Molecular surfaces 
if (opt.find('surface'));
echo "  computing surface...  ";
refresh;
if (opt=='sesurface') {
  isosurface resolution 3 select(~poly) only molecular; // resolution x is to increase the quality of the exported surface. Default is resolution 1 which is fast, but of low quality. 2 is so and so, 3 looks good enough and computation time for 2HHB is acceptable, for 4 and more  computation time increases. Might require some tweaking, maybe somehow related to the prin scale - low print scare should require lower resolution. 
}
if (opt=='sasurface') {
  isosurface resolution 3 select(~poly) only sasurface; 
}
color isosurface @cSurf;
center all;
select ~poly and not connected(not ~poly);
hBonds 0;
rSet(); // hide other renderings inside the surface
struts 0;
select all;
endif;

select all;
echo;
refresh;

// End of the part from Dr. Angel Herráez, Biochemistry and Molecular Biology, Dept. of Systems Biology, University of Alcalá, E-28805 Alcalá de Henares  (Madrid), Spain (https://biomodel.uah.es/).

print "-----debugg values for checking new formulas---------";
print "PrintScaleFactor " + PrintScaleFactor;
print "bonds_radius " + bonds_radius;
print "MinBondLength " +MinBondLength;
print "ScaledMinBondLength " +ScaledMinBondLength;
print "Largest Spacefill Value: " + maxSpacefill + " Å";
print "Smalest Spacefill Value: " + minSpacefill + " Å";
print "AtomsScaledPercentMax: " + AtomsScaledPercentMax + " %";
print "AtomsScaledPercentMax2: " + AtomsScaledPercentMax2 + " %";
print "AtomsScaledPercent: " + AtomsScaledPercent+ " %";
print "AtomsScaledPercent_corrected: " + AtomsScaledPercent_corrected+ " %";
print "MinThresholdScaleFactorBallStick: " + MinThresholdScaleFactorBallStick+ " %";
print "MinThresholdScaleFactorBackbone: " + MinThresholdScaleFactorBackbone+ " %";
print "MinThresholdScaleFactorTrace: " + MinThresholdScaleFactorTrace+ " %";
print "MinThresholdScaleFactorRibbon: " + MinThresholdScaleFactorRibbon+ " %";
print "MinThresholdScaleFactorCartoon: " + MinThresholdScaleFactorCartoon+ " %";
print "MinThresholdScaleFactorSpacefill: " + MinThresholdScaleFactorSpacefill+ " %";
var check = MinThresholdScaleFactorRibbon
print "check " + check; 

write test.stl
